{"ast":null,"code":"var _jsxFileName = \"/Users/jonathancook/Desktop/Research/dep-graph/src/components/GraphDisplay.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useCallback, useRef, useState, forwardRef, useImperativeHandle } from 'react';\nimport ReactFlow, { useNodesState, useEdgesState, useReactFlow } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { applyStyles } from '../utils/GraphUtils';\nimport ace from 'ace-builds';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GraphDisplay = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  nodes: initialNodes,\n  edges: initialEdges,\n  order,\n  editorRef,\n  activeTab\n}, ref) => {\n  _s();\n  const [nodes, setNodesState, onNodesChange] = useNodesState([]);\n  const [edges, setEdgesState, onEdgesChange] = useEdgesState([]);\n  const {\n    fitView\n  } = useReactFlow();\n  const animationTimeoutRef = useRef([]);\n  const colorClassesRef = useRef(new Map());\n  const [animationRun, setAnimationRun] = useState(false);\n\n  // Store line highlights separately for each view\n  const lineHighlights = useRef({\n    Original: {},\n    Decomposed: {}\n  });\n  const createColorClass = color => {\n    if (!colorClassesRef.current.has(color)) {\n      const className = `highlight-${color.replace('#', '')}`;\n      const style = document.createElement('style');\n      style.innerHTML = `\n        .${className} {\n          position: absolute;\n          background: ${color}40;\n          z-index: 20;\n        }\n      `;\n      document.head.appendChild(style);\n      colorClassesRef.current.set(color, className);\n    }\n    return colorClassesRef.current.get(color);\n  };\n  const highlightCodeLines = useCallback((lineNumbers, color, view) => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      const Range = ace.require('ace/range').Range;\n      const colorClass = createColorClass(color);\n      lineNumbers.forEach(line => {\n        // Remove any existing marker for the line in this view before adding a new one\n        if (lineHighlights.current[view][line]) {\n          session.removeMarker(lineHighlights.current[view][line].markerId);\n        }\n        const markerId = session.addMarker(new Range(line - 1, 0, line - 1, 1), colorClass, 'fullLine');\n        lineHighlights.current[view][line] = {\n          markerId,\n          colorClass\n        };\n      });\n    }\n  }, [editorRef]);\n  const runColorAnimation = useCallback(() => {\n    if (!order || !order.length) return;\n    setAnimationRun(true);\n    animationTimeoutRef.current.forEach(clearTimeout);\n    animationTimeoutRef.current = [];\n\n    // Clear existing highlights in both tabs before starting a new animation\n    clearMarkers('Original');\n    clearMarkers('Decomposed');\n    let delay = 0;\n    order.forEach(([id, color]) => {\n      animationTimeoutRef.current.push(setTimeout(() => {\n        setNodesState(nds => nds.map(node => {\n          if (node.id === id) {\n            // Highlight lines for both views and save them independently\n            const linePropertyOriginal = 'code_lines';\n            const linePropertyDecomp = 'decomp_code_lines';\n            if (node[linePropertyOriginal]) {\n              highlightCodeLines(node[linePropertyOriginal], color, 'Original');\n            }\n            if (node[linePropertyDecomp]) {\n              highlightCodeLines(node[linePropertyDecomp], color, 'Decomposed');\n            }\n            return {\n              ...node,\n              style: {\n                ...node.style,\n                background: color\n              }\n            };\n          }\n          return node;\n        }));\n        setEdgesState(eds => eds.map(edge => {\n          if (edge.id === id) {\n            return {\n              ...edge,\n              animated: true,\n              style: {\n                ...edge.style,\n                stroke: color,\n                strokeWidth: 6\n              }\n            };\n          }\n          return edge;\n        }));\n      }, delay));\n      delay += 500;\n    });\n  }, [order, setNodesState, setEdgesState, highlightCodeLines]);\n  const clearMarkers = view => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      Object.values(lineHighlights.current[view]).forEach(({\n        markerId\n      }) => session.removeMarker(markerId));\n      lineHighlights.current[view] = {}; // Reset markers for this view\n    }\n  };\n  const applyMarkersForView = view => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      Object.entries(lineHighlights.current[view]).forEach(([line, {\n        colorClass\n      }]) => {\n        const markerId = session.addMarker(new ace.Range(line - 1, 0, line - 1, 1), colorClass, 'fullLine');\n        lineHighlights.current[view][line] = {\n          markerId,\n          colorClass\n        };\n      });\n    }\n  };\n  useImperativeHandle(ref, () => ({\n    resetGraphColors() {\n      animationTimeoutRef.current.forEach(clearTimeout);\n      animationTimeoutRef.current = [];\n      setNodesState(nds => nds.map(node => ({\n        ...node,\n        style: {\n          ...node.style,\n          background: '#D3D3D3'\n        }\n      })));\n      setEdgesState(eds => eds.map(edge => ({\n        ...edge,\n        style: {\n          ...edge.style,\n          stroke: '#D3D3D3'\n        }\n      })));\n\n      // Clear markers for both views\n      clearMarkers('Original');\n      clearMarkers('Decomposed');\n      setAnimationRun(false);\n    }\n  }));\n\n  // Reapply markers on tab switch\n  useEffect(() => {\n    if (!animationRun) return;\n    const view = activeTab;\n    const otherView = activeTab === 'Original' ? 'Decomposed' : 'Original';\n    clearMarkers(otherView); // Clear other tabâ€™s highlights\n    applyMarkersForView(view); // Apply highlights specific to the active tab\n  }, [activeTab, animationRun]);\n  useEffect(() => {\n    if (nodes.length && edges.length && !animationRun) {\n      runColorAnimation();\n    }\n  }, [nodes, edges, runColorAnimation, animationRun]);\n  useEffect(() => {\n    if (initialNodes.length && initialEdges.length) {\n      const {\n        styledNodes,\n        styledEdges\n      } = applyStyles(initialNodes, initialEdges);\n      setNodesState(styledNodes);\n      setEdgesState(styledEdges);\n      fitView();\n    }\n  }, [initialNodes, initialEdges, setNodesState, setEdgesState, fitView]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"graph-display\",\n    children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n      nodes: nodes,\n      edges: edges,\n      onNodesChange: onNodesChange,\n      onEdgesChange: onEdgesChange,\n      fitView: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 196,\n    columnNumber: 5\n  }, this);\n}, \"/qjaGQWFX9XacFWjxLfuIxYSleA=\", false, function () {\n  return [useNodesState, useEdgesState, useReactFlow];\n})), \"/qjaGQWFX9XacFWjxLfuIxYSleA=\", false, function () {\n  return [useNodesState, useEdgesState, useReactFlow];\n});\n_c2 = GraphDisplay;\nexport default GraphDisplay;\nvar _c, _c2;\n$RefreshReg$(_c, \"GraphDisplay$forwardRef\");\n$RefreshReg$(_c2, \"GraphDisplay\");","map":{"version":3,"names":["React","useEffect","useCallback","useRef","useState","forwardRef","useImperativeHandle","ReactFlow","useNodesState","useEdgesState","useReactFlow","applyStyles","ace","jsxDEV","_jsxDEV","GraphDisplay","_s","_c","nodes","initialNodes","edges","initialEdges","order","editorRef","activeTab","ref","setNodesState","onNodesChange","setEdgesState","onEdgesChange","fitView","animationTimeoutRef","colorClassesRef","Map","animationRun","setAnimationRun","lineHighlights","Original","Decomposed","createColorClass","color","current","has","className","replace","style","document","createElement","innerHTML","head","appendChild","set","get","highlightCodeLines","lineNumbers","view","editor","session","getSession","Range","require","colorClass","forEach","line","removeMarker","markerId","addMarker","runColorAnimation","length","clearTimeout","clearMarkers","delay","id","push","setTimeout","nds","map","node","linePropertyOriginal","linePropertyDecomp","background","eds","edge","animated","stroke","strokeWidth","Object","values","applyMarkersForView","entries","resetGraphColors","otherView","styledNodes","styledEdges","children","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/jonathancook/Desktop/Research/dep-graph/src/components/GraphDisplay.js"],"sourcesContent":["import React, { useEffect, useCallback, useRef, useState, forwardRef, useImperativeHandle } from 'react';\nimport ReactFlow, { useNodesState, useEdgesState, useReactFlow } from 'reactflow';\nimport 'reactflow/dist/style.css';\nimport { applyStyles } from '../utils/GraphUtils';\nimport ace from 'ace-builds';\n\nconst GraphDisplay = forwardRef(({ nodes: initialNodes, edges: initialEdges, order, editorRef, activeTab }, ref) => {\n  const [nodes, setNodesState, onNodesChange] = useNodesState([]);\n  const [edges, setEdgesState, onEdgesChange] = useEdgesState([]);\n  const { fitView } = useReactFlow();\n  const animationTimeoutRef = useRef([]);\n  const colorClassesRef = useRef(new Map());\n  const [animationRun, setAnimationRun] = useState(false);\n\n  // Store line highlights separately for each view\n  const lineHighlights = useRef({ Original: {}, Decomposed: {} });\n\n  const createColorClass = (color) => {\n    if (!colorClassesRef.current.has(color)) {\n      const className = `highlight-${color.replace('#', '')}`;\n      const style = document.createElement('style');\n      style.innerHTML = `\n        .${className} {\n          position: absolute;\n          background: ${color}40;\n          z-index: 20;\n        }\n      `;\n      document.head.appendChild(style);\n      colorClassesRef.current.set(color, className);\n    }\n    return colorClassesRef.current.get(color);\n  };\n\n  const highlightCodeLines = useCallback((lineNumbers, color, view) => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      const Range = ace.require('ace/range').Range;\n      const colorClass = createColorClass(color);\n\n      lineNumbers.forEach((line) => {\n        // Remove any existing marker for the line in this view before adding a new one\n        if (lineHighlights.current[view][line]) {\n          session.removeMarker(lineHighlights.current[view][line].markerId);\n        }\n\n        const markerId = session.addMarker(new Range(line - 1, 0, line - 1, 1), colorClass, 'fullLine');\n        lineHighlights.current[view][line] = { markerId, colorClass };\n      });\n    }\n  }, [editorRef]);\n\n  const runColorAnimation = useCallback(() => {\n    if (!order || !order.length) return;\n\n    setAnimationRun(true);\n    animationTimeoutRef.current.forEach(clearTimeout);\n    animationTimeoutRef.current = [];\n\n    // Clear existing highlights in both tabs before starting a new animation\n    clearMarkers('Original');\n    clearMarkers('Decomposed');\n\n    let delay = 0;\n\n    order.forEach(([id, color]) => {\n      animationTimeoutRef.current.push(\n        setTimeout(() => {\n          setNodesState((nds) =>\n            nds.map((node) => {\n              if (node.id === id) {\n                // Highlight lines for both views and save them independently\n                const linePropertyOriginal = 'code_lines';\n                const linePropertyDecomp = 'decomp_code_lines';\n\n                if (node[linePropertyOriginal]) {\n                  highlightCodeLines(node[linePropertyOriginal], color, 'Original');\n                }\n\n                if (node[linePropertyDecomp]) {\n                  highlightCodeLines(node[linePropertyDecomp], color, 'Decomposed');\n                }\n\n                return {\n                  ...node,\n                  style: {\n                    ...node.style,\n                    background: color,\n                  },\n                };\n              }\n              return node;\n            })\n          );\n\n          setEdgesState((eds) =>\n            eds.map((edge) => {\n              if (edge.id === id) {\n                return {\n                  ...edge,\n                  animated: true,\n                  style: {\n                    ...edge.style,\n                    stroke: color,\n                    strokeWidth: 6,\n                  },\n                };\n              }\n              return edge;\n            })\n          );\n        }, delay)\n      );\n\n      delay += 500;\n    });\n  }, [order, setNodesState, setEdgesState, highlightCodeLines]);\n\n  const clearMarkers = (view) => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      Object.values(lineHighlights.current[view]).forEach(({ markerId }) => session.removeMarker(markerId));\n      lineHighlights.current[view] = {}; // Reset markers for this view\n    }\n  };\n\n  const applyMarkersForView = (view) => {\n    if (editorRef.current && editorRef.current.editor) {\n      const session = editorRef.current.editor.getSession();\n      Object.entries(lineHighlights.current[view]).forEach(([line, { colorClass }]) => {\n        const markerId = session.addMarker(new ace.Range(line - 1, 0, line - 1, 1), colorClass, 'fullLine');\n        lineHighlights.current[view][line] = { markerId, colorClass };\n      });\n    }\n  };\n\n  useImperativeHandle(ref, () => ({\n    resetGraphColors() {\n      animationTimeoutRef.current.forEach(clearTimeout);\n      animationTimeoutRef.current = [];\n\n      setNodesState((nds) =>\n        nds.map((node) => ({\n          ...node,\n          style: {\n            ...node.style,\n            background: '#D3D3D3',\n          },\n        }))\n      );\n\n      setEdgesState((eds) =>\n        eds.map((edge) => ({\n          ...edge,\n          style: {\n            ...edge.style,\n            stroke: '#D3D3D3',\n          },\n        }))\n      );\n\n      // Clear markers for both views\n      clearMarkers('Original');\n      clearMarkers('Decomposed');\n      setAnimationRun(false);\n    },\n  }));\n\n  // Reapply markers on tab switch\n  useEffect(() => {\n    if (!animationRun) return;\n\n    const view = activeTab;\n    const otherView = activeTab === 'Original' ? 'Decomposed' : 'Original';\n\n    clearMarkers(otherView); // Clear other tabâ€™s highlights\n    applyMarkersForView(view); // Apply highlights specific to the active tab\n  }, [activeTab, animationRun]);\n\n  useEffect(() => {\n    if (nodes.length && edges.length && !animationRun) {\n      runColorAnimation();\n    }\n  }, [nodes, edges, runColorAnimation, animationRun]);\n\n  useEffect(() => {\n    if (initialNodes.length && initialEdges.length) {\n      const { styledNodes, styledEdges } = applyStyles(initialNodes, initialEdges);\n      setNodesState(styledNodes);\n      setEdgesState(styledEdges);\n      fitView();\n    }\n  }, [initialNodes, initialEdges, setNodesState, setEdgesState, fitView]);\n\n  return (\n    <div className=\"graph-display\">\n      <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} onEdgesChange={onEdgesChange} fitView />\n    </div>\n  );\n});\n\nexport default GraphDisplay;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}